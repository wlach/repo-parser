import pathlib
import re
from dataclasses import dataclass
from pathlib import PurePath
from typing import List, Optional

import git

from .processor import Processor


@dataclass
class File:
    name: str
    src_path: PurePath
    content: Optional[str]


@dataclass
class Dir:
    path: pathlib.Path
    files: List[File]
    dirs: List["Dir"]


def _scan(
    path: pathlib.Path,
    processors: List[Processor],
    ignore_patterns: List[re.Pattern],
    repo: git.Repo,
    depth: int,
    max_depth: Optional[int],
) -> Dir:
    dir = Dir(path=pathlib.PurePath(path), files=[], dirs=[])
    entries = [entry for entry in path.iterdir()]
    if not entries:
        return dir
    resolved_entries = {str(entry.resolve()) for entry in entries}

    # remove any entries which match our ignore patterns (e.g. autogenerated files)
    ignored = {
        resolved_entry
        for resolved_entry in resolved_entries
        if any(
            [
                re.search(pattern, resolved_entry) is not None
                for pattern in ignore_patterns
            ]
        )
    }
    # also ignore anything .gitignored (doing this second because it's a likely a little
    # more time consuming)
    remaining_entries = resolved_entries - ignored
    if remaining_entries:
        ignored |= set(repo.ignored(*remaining_entries))

    for entry in entries:
        # FIXME: At some point we should only ignore .git in the root directory
        if entry.name == ".git" or str(entry.resolve()) in ignored:
            continue
        elif entry.is_file():
            for processor in processors:
                if processor.pattern.search(str(entry)):
                    content = entry.read_text() if processor.read_content else None
                    dir.files.append(
                        File(
                            name=entry.name,
                            src_path=(path / entry.name),
                            content=content,
                        )
                    )
        elif entry.is_dir() and (max_depth is None or depth < max_depth):
            dir.dirs.append(
                _scan(
                    path / entry.name,
                    processors,
                    ignore_patterns,
                    repo,
                    depth + 1,
                    max_depth,
                )
            )

    return dir


def scan(
    path: pathlib.Path,
    processors: List[Processor],
    ignore_patterns: Optional[List[re.Pattern]] = None,
    subdirs: Optional[List[pathlib.Path]] = None,
    max_depth: Optional[int] = None,
) -> Dir:
    """
    Scans a GitHub repository for files and subdirectories, returning a data
    structure representing the directory tree.

    Takes in a list of processors to figure out which files should be included
    in the returned tree.

    Under the hood, this uses the `git` library to scan the repository, skipping
    files in .gitignore.

    This step does not do any post-processing of the files, though their
    content is read in if one of their processors requires it.
    """
    repo = git.Repo(path)

    # if subdirs, just scan each one and return the results
    if subdirs:
        dir = Dir(path=pathlib.PurePath(path), files=[], dirs=[])
        for subdir in subdirs:
            dir.dirs.append(
                _scan(
                    path / subdir, processors, ignore_patterns or [], repo, 0, max_depth
                )
            )
        return dir

    # otherwise read everything up to max_depth
    return _scan(path, processors, ignore_patterns or [], repo, 0, max_depth)
