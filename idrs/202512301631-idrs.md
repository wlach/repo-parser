# Implementation Decision Records (idrs)

Owner: Will Lachance <wlach@protonmail.com>

_This IDR describes the IDR format itself—a bit meta, but it demonstrates the format in action._

## Overview

### Problem Statement

Make it easier to implement modifications and improvements to software while documenting the result.

### Context (as needed)

LLM coding agents (late 2025) can make large, coherent changes but don't naturally
capture _why_ choices were made—only _what_ was done.

Existing formats don't fit well:

- Design docs: good for brainstorming and discussion, expensive to maintain during implementation
- ADRs: capture decisions, but deliberately exclude implementation details

Desired: something that lives in-repo, captures both intent and execution details,
can guide both humans and machines (LLMs as of late 2025), and is explicitly ephemeral.

This is an experiment to see if such a format is useful.

### Goals

- Provide scaffolding for humans to understand an approach before and during
  implementation
- Provide scaffolding for automated systems (e.g. LLMs) to use as an implementation
  guide, as well as critique during brainstorming.

### Non-Goals

- Provide the _best_ possible ergonomics for discussing a design or approach (Google docs or similar are always going to better)
- Be a scaffolding for literary works of art (idrs are intended to be functional)
- Be long lived documentation (idrs are a snapshot in time)

### Proposed Solution

Command-line tooling for creating idrs using repo-parser, for the use of humans
as well as developer productivity tooling (LLM Agents in circa late 2025). This
implementation summary can and will be updated during implementation, and should be
committed to Git and included in the pull request at the end of that process.

## Detailed Design (as needed)

Create the following functionality in the repo-parser library:

- An idr template (under `repo_parser/templates`) allowing creation of an idr.
- A command-line tool (`rp`) with a single sub-command: `idr`. You can create
  an idr with it by running `rp idr new <title of idr>`. For example: `rp idr new Add last modified metadata` and (on Dec 30 at 16:00 UTC) it would create a file called
  `idrs/202512301600-add-last-modified-metadata.md`.

### idr template structure

The IDR template has the following structure:

```md
# {{ title }}

Author: {{ author }}

## Overview

### Problem Statement

### Context (as needed)

### Goals

### Non-Goals

### Proposed Solution

## Detailed Design (as needed)

## Rollout plan (as needed)

## Cross cutting concerns (as needed)

## Alternatives considered (as needed)

## Future plans (as needed)

## Other reading (as needed)

## Implementation (ephemeral)
```

## Rollout plan (as needed)

Roll out as a basic feature in repo-parser, validate approach by using it to guide
implementation within repo-parser itself.

## Cross cutting concerns (as needed)

### Trust

As used in 2025/2026, these artifacts will often be partially generated by LLMs.
Without safeguards, they risk becoming inaccurate [work slop](https://www.404media.co/ai-workslop-is-killing-productivity-and-making-workers-miserable/).

**Mitigation strategies:**

1. **Review checkpoints**: IDRs must be human-reviewed at:

   - Initial creation (ensure problem statement is accurate)
   - Implementation completion (verify "Implementation" section matches reality)
   - PR review (confirm all technical details are correct)

2. **Validation prompts**: When using LLM assistance, always ask:

   - "Is every word here true and accurate to the current implementation?"
   - "Are there any speculative or aspirational statements presented as facts?"
   - "Do all code/file references actually exist?"

3. **Accountability**: IDRs should have a named author who takes responsibility for accuracy

4. **Ephemeral by design**: The "Implementation (ephemeral)" section acknowledges these are snapshots, not evergreen docs.

**Future tooling**: Consider automated validation (checking file references, detecting hallucination patterns, comparing against actual git diffs).

## Alternatives considered (as needed)

- Markdown ADRs aka [MADRs](https://adr.github.io/madr/): Has some commonalities (e.g. use of markdown). As generally used, much more concise than an implementation decision record and intended purely for human consumption. Generally feel like a document format that allows (but doesn't require!) more colour/thinking about the shape of an implementation is potentially useful.
- Traditional Design Docs circulated as Google Docs or similar: These are great! But often much heavier and almost invariably diverge from implementation (unless written deliberately). They also tend to be difficult to search for and find in most organizations. Generally most useful when trying to get buy-in or feedback from others. IDRs are generally for the benefit of implementors, their tools (LLMs in late 2025) and PR reviewers.

## Future plans (as needed)

None yet! This is an experiment, seeing if it works out.

## Other reading (as needed)

- [Design Docs at Google](https://www.industrialempathy.com/posts/design-docs-at-google/)
- [Architectural Decision Records (ADRs)](https://adr.github.io/)

## Implementation (ephemeral)

### Implementation checklist

- [x] Create `repo_parser/templates/` directory
- [x] Move `idr-template.md` to `repo_parser/templates/idr.md`
- [x] Create `repo_parser/cli.py` module with `rp idr new` command
- [x] Add CLI entry point to `pyproject.toml` (`[project.scripts]`)
- [x] Add `python-slugify` to main dependencies
- [x] Move `jinja2` and `typer` from dev dependencies to main dependencies
- [x] Implement author detection from git config
- [x] Implement file naming logic (timestamp + slugified title)
- [x] Add error handling for common cases
- [x] Write tests for CLI functionality
- [x] Update README with usage example, motivation and explanation

### Implementation notes

**Completed**: December 30, 2025

All items from the checklist have been implemented and tested:

1. **Directory structure**: Created `repo_parser/templates/` and moved template file
2. **CLI module**: Implemented `repo_parser/cli.py` with full functionality
3. **Dependencies**: Updated `pyproject.toml` to include jinja2, typer, and python-slugify in main dependencies
4. **Entry point**: Added `[project.scripts]` with `rp` command
5. **Tests**: Created comprehensive test suite in `tests/test_cli.py`, all passing
6. **Documentation**: Updated README.md with installation and usage instructions

**Key implementation details**:

- Template loading uses `importlib.resources` for package data
- UTC timezone used for timestamps
- Author detection falls back to "Unknown" if git config not available
- Error handling uses `raise ... from e` pattern per AGENTS.md guidelines
- All tests pass, linting clean with ruff

**Manual testing**:

```bash
$ uv run python -m repo_parser.cli idr new "Test IDR Creation"
Created IDR: /home/wlach/src/repo-parser/idrs/202512302057-test-idr-creation.md
```

Template correctly renders with title and author from git config.

### Technical decisions

**CLI Framework**: Use `typer` (already in dev dependencies). Clean API, good for simple CLIs.

**Template location**: `repo_parser/templates/idr.md`

- Need to configure as package data in `pyproject.toml`? May need to use `importlib.resources` or similar to load template from installed package

**Author detection strategy**:

```python
# Priority order:
1. CLI argument: `--author "Name"` (if we add this flag)
2. Git config: `git config user.name`
3. Fallback: "Unknown"
```

**Timestamp format**: `YYYYMMDDHHmm` in UTC

- Example: `202512301600` for Dec 30, 2025, 4:00 PM UTC
- Always use UTC

**Title slugification**:

```python
# Convert: "Add last modified metadata"
# To: "add-last-modified-metadata"
# Rules:
# - lowercase
# - replace spaces with hyphens
# - remove special characters (keep alphanumeric and hyphens)
# - collapse multiple hyphens to single
# - use `python-slugify` (add to dependencies)
```

**Output directory**:

- Default: `idrs/` relative to location of where the `rp` command is run
- Create directory if it doesn't exist

**Error handling**:

- Not in git repo: Error with clear message
- File already exists: Generate custom exception, should never happen
- Template missing: Error with clear message

**Entry point in pyproject.toml**:

```toml
[project.scripts]
rp = "repo_parser.cli:app"
```

**Template rendering**:

- Use Jinja2 to render `{{ title }}` and `{{ author }}`
- Template variables: `title` (as provided), `author` (from git config)

### Files to create/modify

**New files**:

- `repo_parser/cli.py` - Main CLI module
- `repo_parser/templates/idr.md` - Template file (moved from root) - use `[tool.flit.sdist]` or similar configuration to be sure it's built into the wheel.

**Modified files**:

- `pyproject.toml` - Add scripts entry point, move dependencies
- `README.md` - Add usage documentation

**Test files**:

- `tests/test_cli.py` - Test CLI functionality
